// 1047. 删除字符串中的所有相邻重复项
// 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

// 在 S 上反复执行重复项删除操作，直到无法继续删除。

// 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

// 示例：
// 输入："abbaca"
// 输出："ca"
// 解释：
// 例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
 
// 提示：
// 1 <= S.length <= 20000
// S 仅由小写英文字母组成。


// 时间复杂度，空间复杂度：O(n)
var removeDuplicates = function(S) {
    var stack = []
    for(c of S) { // 遍历字符串的每一个字符
        var prev = stack.pop() // 获取栈头元素
        if(prev !== c) { // 判断两个字符是否不相同
            stack.push(prev) // 入栈 （入栈顺序）
            stack.push(c) // 入栈（入栈顺序）
        }
    }
    return stack.join('')
};

// 正则
var removeDuplicates = function(S) {
    var reg = /(\w)\1/g;
    while(S.match(reg) !== null) {
        S = S.replace(reg, '');
    }
    return S;
};

// 总结：
// 我原先的思路是遍历一边就删除里面的重复项，但是发现这样得保存删除后字符串得结果。
// 然后重新在遍历一边，得不断地循环遍历，直到没有重复项的时候停止

// 这样就使得我必须：
// 1.在删除操作之后得保存字符串结果
// 2.得多次遍历字符串
// 3.得判断字符串中是否还存在重复项（作为多次循环的出口）
// 很显然，就第三点就很难实现

// 而使用遍历 + 栈就可以很好解决这些问题，遍历还是正常去遍历字符串，但是操作围绕栈来控制。
// 操作包括：
// 保存元素
// 删除元素
// 获取栈头元素和最新元素比较